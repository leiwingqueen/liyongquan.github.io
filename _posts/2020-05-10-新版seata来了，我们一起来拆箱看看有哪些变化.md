---
layout: post
title:  "新版seata来了，我们一起来拆箱看看有哪些变化"
description: 新版seata来了，我们一起来拆箱看看有哪些变化
date:   2020-05-10 18:39:00 +000
categories: seata 分布式事务
tags: seata 分布式事务
---

### 一、seata是什么

> Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。

[seata官方网站](http://seata.io/zh-cn/index.html)

在19年初的时候就关注过这个中间件(当时叫Fescar)，并且对它的源码进行了一下分析--[阿里分布式事务解决方案fescar简析](https://www.jianshu.com/p/fdb59ee7e9ff)。然而当时并不成熟，并不能直接用于商用，主要有以下几个问题。

- TC的实现不完善。不支持HA，xid的生成，session的存储，锁的实现等都是以DEMO的方式提供，不能直接用于线上环境，需要二次开发
- 回滚失败的补偿机制不完善
- 性能问题。seata当时宣称只有在第一阶段提交的时候进行加锁，相对传统的两阶段提交对性能有比较大的提升。但现实情况是为了保证回滚操作的成功，还必须要有一个全局锁，事实上相比XA的方式我个人认为在系统的吞吐量上个人认为不会有太大的变化。而且由于这种方式实现的是类似补偿性事务的方式，又会引入一个可见性的问题(第二阶段提交前就已经能看到第一阶段提交的结果)
- RPC框架。由于是阿里系的中间件，因此第一版实现的是基于dubbo，非dubbo的rpc框架需要根据自己的情况做二次开发。

### 二、模式

- AT
- TCC
- SAGA(新特性)
- XA(新特性)

### 三、核心组件

- TC

事务协调者

- TM

事务发起者。定义事务边界

- RM

事务参与者

### 四、demo演示



### 五、源码分析

注：本文使用的版本为v1.2.0

#### 1. undo_log的产生和删除机制

- undo_log的写入流程

![UndoLogManager类图](https://leiwingqueen-1300197911.cos.ap-guangzhou.myqcloud.com/seata/MySQLUndoLogManager.png)

查看flushUndoLogs调用栈

```java
flushUndoLogs:200, AbstractUndoLogManager (io.seata.rm.datasource.undo)
processGlobalTransactionCommit:221, ConnectionProxy (io.seata.rm.datasource)
doCommit:196, ConnectionProxy (io.seata.rm.datasource)
lambda$commit$0:184, ConnectionProxy (io.seata.rm.datasource)
call:-1, 362578118 (io.seata.rm.datasource.ConnectionProxy$$Lambda$197)
execute:289, ConnectionProxy$LockRetryPolicy (io.seata.rm.datasource)
commit:183, ConnectionProxy (io.seata.rm.datasource)
...
execute:108, ExecuteTemplate (io.seata.rm.datasource.exec)
execute:49, ExecuteTemplate (io.seata.rm.datasource.exec)
...
update:927, JdbcTemplate (org.springframework.jdbc.core)
deduct:51, StorageServiceImpl (io.seata.samples.dubbo.service.impl)
```

ConnectionProxy为Connection的代理类。

在事务提交之前，做两件事情

- 注册分支事务到TC
- 写入undo_log

```java
private void processGlobalTransactionCommit() throws SQLException {
        try {
            //**新特性，分支事务注册到TC改为在提交前进行，而不是在一开始就获取一个branchId
            register();
        } catch (TransactionException e) {
            recognizeLockKeyConflictException(e, context.buildLockKeys());
        }
        try {
            //根据数据库的类型获取对应的UndoLogManager进行刷写undolog日志
            UndoLogManagerFactory.getUndoLogManager(this.getDbType()).flushUndoLogs(this);
            //原connection的commit操作
            targetConnection.commit();
        } catch (Throwable ex) {
            LOGGER.error("process connectionProxy commit error: {}", ex.getMessage(), ex);
            report(false);
            throw new SQLException(ex);
        }
        if (IS_REPORT_SUCCESS_ENABLE) {
            report(true);
        }
        context.reset();
    }
```

>  AbstractUndoLogManager.java

```java
@Override
    public void flushUndoLogs(ConnectionProxy cp) throws SQLException {
        //通过连接代理获取连接的上下文，这里先不分析xid的传递机制，留给后面的部分进行分析
        ConnectionContext connectionContext = cp.getContext();
        if (!connectionContext.hasUndoLog()) {
            return;
        }

        String xid = connectionContext.getXid();
        long branchId = connectionContext.getBranchId();

        BranchUndoLog branchUndoLog = new BranchUndoLog();
        branchUndoLog.setXid(xid);
        branchUndoLog.setBranchId(branchId);
        //具体的undolog的内容
        branchUndoLog.setSqlUndoLogs(connectionContext.getUndoItems());

        UndoLogParser parser = UndoLogParserFactory.getInstance();
        byte[] undoLogContent = parser.encode(branchUndoLog);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Flushing UNDO LOG: {}", new String(undoLogContent, Constants.DEFAULT_CHARSET));
        }
        //实际的写入操作，不同的关系型数据库有不同的实现
        insertUndoLogWithNormal(xid, branchId, buildContext(parser.getName()), undoLogContent,
            cp.getTargetConnection());
    }
```

为了直观显示，我这里给出了一条undo_log的数据

```sql
           id: 32
    branch_id: 2011290555
          xid: 172.17.0.1:8091:2011290554
      context: serializer=jackson
rollback_info: {"@class":"io.seata.rm.datasource.undo.BranchUndoLog","xid":"172.17.0.1:8091:2011290554","branchId":2011290555,"sqlUndoLogs":["java.util.ArrayList",[{"@class":"io.seata.rm.datasource.undo.SQLUndoLog","sqlType":"UPDATE","tableName":"storage_tbl","beforeImage":{"@class":"io.seata.rm.datasource.sql.struct.TableRecords","tableName":"storage_tbl","rows":["java.util.ArrayList",[{"@class":"io.seata.rm.datasource.sql.struct.Row","fields":["java.util.ArrayList",[{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"id","keyType":"PRIMARY_KEY","type":4,"value":4},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"count","keyType":"NULL","type":4,"value":201}]]}]]},"afterImage":{"@class":"io.seata.rm.datasource.sql.struct.TableRecords","tableName":"storage_tbl","rows":["java.util.ArrayList",[{"@class":"io.seata.rm.datasource.sql.struct.Row","fields":["java.util.ArrayList",[{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"id","keyType":"PRIMARY_KEY","type":4,"value":4},{"@class":"io.seata.rm.datasource.sql.struct.Field","name":"count","keyType":"NULL","type":4,"value":199}]]}]]}}]]}
   log_status: 0
  log_created: 2020-05-10 10:02:53
 log_modified: 2020-05-10 10:02:53
          ext: NULLstruct

```

这个操作为把用户的库存记录-2。beforeImage的count为201，afterImage的count为199。

- undo_log的生成

ExecuteTemplate.execute

```java
public static <T, S extends Statement> T execute(List<SQLRecognizer> sqlRecognizers,
                                                     StatementProxy<S> statementProxy,
                                                     StatementCallback<T, S> statementCallback,
                                                     Object... args) throws SQLException {

        if (!RootContext.inGlobalTransaction() && !RootContext.requireGlobalLock()) {
            // Just work as original statement
            return statementCallback.execute(statementProxy.getTargetStatement(), args);
        }

        if (sqlRecognizers == null) {
            sqlRecognizers = SQLVisitorFactory.get(
                    statementProxy.getTargetSQL(),
                    statementProxy.getConnectionProxy().getDbType());
        }
        Executor<T> executor;
        if (CollectionUtils.isEmpty(sqlRecognizers)) {
            executor = new PlainExecutor<>(statementProxy, statementCallback);
        } else {
            if (sqlRecognizers.size() == 1) {
                SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);
                switch (sqlRecognizer.getSQLType()) {
                    case INSERT:
                        executor = new InsertExecutor<>(statementProxy, statementCallback, sqlRecognizer);
                        break;
                    case UPDATE:
                        executor = new UpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);
                        break;
                    case DELETE:
                        executor = new DeleteExecutor<>(statementProxy, statementCallback, sqlRecognizer);
                        break;
                    case SELECT_FOR_UPDATE:
                        executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);
                        break;
                    default:
                        executor = new PlainExecutor<>(statementProxy, statementCallback);
                        break;
                }
            } else {
                executor = new MultiExecutor<>(statementProxy, statementCallback, sqlRecognizers);
            }
        }
        T rs;
        try {
            rs = executor.execute(args);
        } catch (Throwable ex) {
            if (!(ex instanceof SQLException)) {
                // Turn other exception into SQLException
                ex = new SQLException(ex);
            }
            throw (SQLException) ex;
        }
        return rs;
    }
```



#### 2.RPC框架整合(xid传递)

![seata的调用关系](http://seata.io/img/solution.png)

这里的调用关系图忽略了一个细节，所有事务的参与者(TM和RM)都必须通过xid关联起来。那么xid在seata内部又是如何传递的？

我们从RootContext入手，看下是如何获得xid

```java
/**
     * Bind.
     *
     * @param xid the xid
     */
    public static void bind(String xid) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("bind {}", xid);
        }
        CONTEXT_HOLDER.put(KEY_XID, xid);
    }
/**
     * Unbind string.
     *
     * @return the string
     */
    public static String unbind() {
        String xid = CONTEXT_HOLDER.remove(KEY_XID);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("unbind {} ", xid);
        }
        return xid;
    }
```

CONTEXT_HOLDER是一个ThreadLocal的对象。我们来看看RootContext.bind的调用栈

```java
bind:87, RootContext (io.seata.core.context)
begin:106, DefaultGlobalTransaction (io.seata.tm.api)
beginTransaction:175, TransactionalTemplate (io.seata.tm.api)
execute:98, TransactionalTemplate (io.seata.tm.api)
handleGlobalTransaction:106, GlobalTransactionalInterceptor (io.seata.spring.annotation)
invoke:83, GlobalTransactionalInterceptor (io.seata.spring.annotation)
proceed:186, ReflectiveMethodInvocation (org.springframework.aop.framework)
intercept:688, CglibAopProxy$DynamicAdvisedInterceptor (org.springframework.aop.framework)
purchase:-1, BusinessServiceImpl$$EnhancerBySpringCGLIB$$78be133f (io.seata.samples.dubbo.service.impl)
purchase_normal:36, BusinessServiceTest (io.seata.samples.dubbo.service)
```

核心逻辑在TransactionalTemplate.execute

```java
try {
    //RootContext初始化就在这里进行
                // 2. begin transaction
                beginTransaction(txInfo, tx);

                Object rs = null;
                try {
                    // Do Your Business
                    rs = business.execute();

                } catch (Throwable ex) {
                    // 这里可以看出来回滚是依赖业务逻辑抛出异常触发的
                    // 3.the needed business exception to rollback.
                    completeTransactionAfterThrowing(txInfo, tx, ex);
                    throw ex;
                }
                // 4. everything is fine, commit.
                commitTransaction(tx);

                return rs;
            } finally {
                //5. clear
                triggerAfterCompletion();
                cleanUp();
            }
```

这里可以比较清晰得看到整个TM/RM的执行流程。

最后在DefaultGlobalTransaction这里类里面初始化RootContext。

```java
public void begin(int timeout, String name) throws TransactionException {
        if (role != GlobalTransactionRole.Launcher) {
            assertXIDNotNull();
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Ignore Begin(): just involved in global transaction [{}]", xid);
            }
            return;
        }
        assertXIDNull();
        if (RootContext.getXID() != null) {
            throw new IllegalStateException();
        }
    //请求TC获得xid，这里会通过transactionServiceGroup获取TC的分组的地址(TC资源隔离)，获得对应的xid
        xid = transactionManager.begin(null, null, name, timeout);
        status = GlobalStatus.Begin;
    //绑定xid到RootContext
        RootContext.bind(xid);
        if (LOGGER.isInfoEnabled()) {
            LOGGER.info("Begin new global transaction [{}]", xid);
        }
    }
```
对于TM，xid是直接从TC获取生成。而RM的xid是由TM在RPC调用的时候同步过来的。下面的RM的DEBUG日志。RM是通过增加一个ApacheDubboTransactionPropagationFilter来保证在接收到请求的时候自动把请求头中的xid解析出来并保存到RootContext。

```shell
[DEBUG] 2020-05-11 23:48:46,324 method:io.seata.integration.dubbo.ApacheDubboTransactionPropagationFilter.invoke(ApacheDubboTransactionPropagationFilter.java:48)
xid in RootContext[null] xid in RpcContext[172.17.0.1:8091:2011290575]
[DEBUG] 2020-05-11 23:48:46,324 method:io.seata.core.context.RootContext.bind(RootContext.java:85)
bind 172.17.0.1:8091:2011290575
```

> ApacheDubboTransactionPropagationFilter.invoke

```java
    @Override
    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {
        String xid = RootContext.getXID();
        String xidInterceptorType = RootContext.getXIDInterceptorType();

        String rpcXid = getRpcXid();
        String rpcXidInterceptorType = RpcContext.getContext().getAttachment(RootContext.KEY_XID_INTERCEPTOR_TYPE);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("xid in RootContext[{}] xid in RpcContext[{}]", xid, rpcXid);
        }
        boolean bind = false;
        if (xid != null) {
            RpcContext.getContext().setAttachment(RootContext.KEY_XID, xid);
            RpcContext.getContext().setAttachment(RootContext.KEY_XID_INTERCEPTOR_TYPE, xidInterceptorType);
        } else {
            //绑定rpcXid到RootContext
            if (rpcXid != null) {
                RootContext.bind(rpcXid);
                RootContext.bindInterceptorType(rpcXidInterceptorType);
                bind = true;
                if (LOGGER.isDebugEnabled()) {
                    LOGGER.debug("bind[{}] interceptorType[{}] to RootContext", rpcXid, rpcXidInterceptorType);
                }
            }
        }
        try {
            //处理实际的业务逻辑
            return invoker.invoke(invocation);
        } finally {
            //处理请求完成后解绑
            if (bind) {
                String unbindInterceptorType = RootContext.unbindInterceptorType();
                String unbindXid = RootContext.unbind();
                ...
            }
        }
    }

    /**
     * get rpc xid
     * @return
     */
    private String getRpcXid() {
        String rpcXid = RpcContext.getContext().getAttachment(RootContext.KEY_XID);
        if (rpcXid == null) {
            rpcXid = RpcContext.getContext().getAttachment(RootContext.KEY_XID.toLowerCase());
        }
        return rpcXid;
    }
```




#### 3. 锁的机制(全局锁和局部锁)

![seata锁](https://img.alicdn.com/tfs/TB138wuwYj1gK0jSZFuXXcrHpXa-724-521.png)

seata的锁分两种local lock和global lock

local lock的核心作用在于保证undo log的准确性。而global lock的主要作用在于保证在全局事务提交之前，RM的数据不会被修改。这里相对第一个版本的优化是在于把global lock放在了第一阶段提交之前进行获取，一定程度上提高了并行度。

![回滚](https://img.alicdn.com/tfs/TB1xW0UwubviK0jSZFNXXaApXXa-718-521.png)
这种事务回滚的方式本质上是触发了死锁导致超时触发的。tx1持有global lock，等待local lock。而tx2持有local lock，等待global lock。最终tx2会超时回滚，从而释放锁，tx1也能继续执行回滚操作。

- local lock的实现



- global lock的实现

- TC-session状态存储
- xid生成